import{a as vt,V as st,C as bt,S as Tt,b as St,T as Mt,Q as mt}from"./cannon-es.4b49244b.js";import{l as G,L as At,w as Pt,x as It,Q as Ct,$ as gt,M as Et,a0 as Bt,y as pt,a1 as yt}from"./three.module.9352233f.js";const O=11102230246251565e-32,k=134217729,Ft=(3+8*O)*O;function et(f,t,e,s,i){let o,l,a,n,r=t[0],d=s[0],u=0,h=0;d>r==d>-r?(o=r,r=t[++u]):(o=d,d=s[++h]);let c=0;if(u<f&&h<e)for(d>r==d>-r?(l=r+o,a=o-(l-r),r=t[++u]):(l=d+o,a=o-(l-d),d=s[++h]),o=l,a!==0&&(i[c++]=a);u<f&&h<e;)d>r==d>-r?(l=o+r,n=l-o,a=o-(l-n)+(r-n),r=t[++u]):(l=o+d,n=l-o,a=o-(l-n)+(d-n),d=s[++h]),o=l,a!==0&&(i[c++]=a);for(;u<f;)l=o+r,n=l-o,a=o-(l-n)+(r-n),r=t[++u],o=l,a!==0&&(i[c++]=a);for(;h<e;)l=o+d,n=l-o,a=o-(l-n)+(d-n),d=s[++h],o=l,a!==0&&(i[c++]=a);return(o!==0||c===0)&&(i[c++]=o),c}function zt(f,t){let e=t[0];for(let s=1;s<f;s++)e+=t[s];return e}function q(f){return new Float64Array(f)}const Ht=(3+16*O)*O,kt=(2+12*O)*O,Lt=(9+64*O)*O*O,V=q(4),rt=q(8),ot=q(12),lt=q(16),L=q(4);function $t(f,t,e,s,i,o,l){let a,n,r,d,u,h,c,m,g,_,p,x,b,T,w,A,E,M;const C=f-i,y=e-i,v=t-o,S=s-o;T=C*S,h=k*C,c=h-(h-C),m=C-c,h=k*S,g=h-(h-S),_=S-g,w=m*_-(T-c*g-m*g-c*_),A=v*y,h=k*v,c=h-(h-v),m=v-c,h=k*y,g=h-(h-y),_=y-g,E=m*_-(A-c*g-m*g-c*_),p=w-E,u=w-p,V[0]=w-(p+u)+(u-E),x=T+p,u=x-T,b=T-(x-u)+(p-u),p=b-A,u=b-p,V[1]=b-(p+u)+(u-A),M=x+p,u=M-x,V[2]=x-(M-u)+(p-u),V[3]=M;let P=zt(4,V),B=kt*l;if(P>=B||-P>=B||(u=f-C,a=f-(C+u)+(u-i),u=e-y,r=e-(y+u)+(u-i),u=t-v,n=t-(v+u)+(u-o),u=s-S,d=s-(S+u)+(u-o),a===0&&n===0&&r===0&&d===0)||(B=Lt*l+Ft*Math.abs(P),P+=C*d+S*a-(v*r+y*n),P>=B||-P>=B))return P;T=a*S,h=k*a,c=h-(h-a),m=a-c,h=k*S,g=h-(h-S),_=S-g,w=m*_-(T-c*g-m*g-c*_),A=n*y,h=k*n,c=h-(h-n),m=n-c,h=k*y,g=h-(h-y),_=y-g,E=m*_-(A-c*g-m*g-c*_),p=w-E,u=w-p,L[0]=w-(p+u)+(u-E),x=T+p,u=x-T,b=T-(x-u)+(p-u),p=b-A,u=b-p,L[1]=b-(p+u)+(u-A),M=x+p,u=M-x,L[2]=x-(M-u)+(p-u),L[3]=M;const $=et(4,V,4,L,rt);T=C*d,h=k*C,c=h-(h-C),m=C-c,h=k*d,g=h-(h-d),_=d-g,w=m*_-(T-c*g-m*g-c*_),A=v*r,h=k*v,c=h-(h-v),m=v-c,h=k*r,g=h-(h-r),_=r-g,E=m*_-(A-c*g-m*g-c*_),p=w-E,u=w-p,L[0]=w-(p+u)+(u-E),x=T+p,u=x-T,b=T-(x-u)+(p-u),p=b-A,u=b-p,L[1]=b-(p+u)+(u-A),M=x+p,u=M-x,L[2]=x-(M-u)+(p-u),L[3]=M;const H=et($,rt,4,L,ot);T=a*d,h=k*a,c=h-(h-a),m=a-c,h=k*d,g=h-(h-d),_=d-g,w=m*_-(T-c*g-m*g-c*_),A=n*r,h=k*n,c=h-(h-n),m=n-c,h=k*r,g=h-(h-r),_=r-g,E=m*_-(A-c*g-m*g-c*_),p=w-E,u=w-p,L[0]=w-(p+u)+(u-E),x=T+p,u=x-T,b=T-(x-u)+(p-u),p=b-A,u=b-p,L[1]=b-(p+u)+(u-A),M=x+p,u=M-x,L[2]=x-(M-u)+(p-u),L[3]=M;const I=et(H,ot,4,L,lt);return lt[I-1]}function Z(f,t,e,s,i,o){const l=(t-o)*(e-i),a=(f-i)*(s-o),n=l-a;if(l===0||a===0||l>0!=a>0)return n;const r=Math.abs(l+a);return Math.abs(n)>=Ht*r?n:-$t(f,t,e,s,i,o,r)}const at=Math.pow(2,-52),D=new Uint32Array(512);class W{static from(t,e=Ut,s=Vt){const i=t.length,o=new Float64Array(i*2);for(let l=0;l<i;l++){const a=t[l];o[2*l]=e(a),o[2*l+1]=s(a)}return new W(o)}constructor(t){const e=t.length>>1;if(e>0&&typeof t[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=t;const s=Math.max(2*e-5,0);this._triangles=new Uint32Array(s*3),this._halfedges=new Int32Array(s*3),this._hashSize=Math.ceil(Math.sqrt(e)),this._hullPrev=new Uint32Array(e),this._hullNext=new Uint32Array(e),this._hullTri=new Uint32Array(e),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(e),this._dists=new Float64Array(e),this.update()}update(){const{coords:t,_hullPrev:e,_hullNext:s,_hullTri:i,_hullHash:o}=this,l=t.length>>1;let a=1/0,n=1/0,r=-1/0,d=-1/0;for(let y=0;y<l;y++){const v=t[2*y],S=t[2*y+1];v<a&&(a=v),S<n&&(n=S),v>r&&(r=v),S>d&&(d=S),this._ids[y]=y}const u=(a+r)/2,h=(n+d)/2;let c=1/0,m,g,_;for(let y=0;y<l;y++){const v=nt(u,h,t[2*y],t[2*y+1]);v<c&&(m=y,c=v)}const p=t[2*m],x=t[2*m+1];c=1/0;for(let y=0;y<l;y++){if(y===m)continue;const v=nt(p,x,t[2*y],t[2*y+1]);v<c&&v>0&&(g=y,c=v)}let b=t[2*g],T=t[2*g+1],w=1/0;for(let y=0;y<l;y++){if(y===m||y===g)continue;const v=Ot(p,x,b,T,t[2*y],t[2*y+1]);v<w&&(_=y,w=v)}let A=t[2*_],E=t[2*_+1];if(w===1/0){for(let S=0;S<l;S++)this._dists[S]=t[2*S]-t[0]||t[2*S+1]-t[1];X(this._ids,this._dists,0,l-1);const y=new Uint32Array(l);let v=0;for(let S=0,P=-1/0;S<l;S++){const B=this._ids[S];this._dists[B]>P&&(y[v++]=B,P=this._dists[B])}this.hull=y.subarray(0,v),this.triangles=new Uint32Array(0),this.halfedges=new Uint32Array(0);return}if(Z(p,x,b,T,A,E)<0){const y=g,v=b,S=T;g=_,b=A,T=E,_=y,A=v,E=S}const M=Nt(p,x,b,T,A,E);this._cx=M.x,this._cy=M.y;for(let y=0;y<l;y++)this._dists[y]=nt(t[2*y],t[2*y+1],M.x,M.y);X(this._ids,this._dists,0,l-1),this._hullStart=m;let C=3;s[m]=e[_]=g,s[g]=e[m]=_,s[_]=e[g]=m,i[m]=0,i[g]=1,i[_]=2,o.fill(-1),o[this._hashKey(p,x)]=m,o[this._hashKey(b,T)]=g,o[this._hashKey(A,E)]=_,this.trianglesLen=0,this._addTriangle(m,g,_,-1,-1,-1);for(let y=0,v,S;y<this._ids.length;y++){const P=this._ids[y],B=t[2*P],$=t[2*P+1];if(y>0&&Math.abs(B-v)<=at&&Math.abs($-S)<=at||(v=B,S=$,P===m||P===g||P===_))continue;let H=0;for(let tt=0,xt=this._hashKey(B,$);tt<this._hashSize&&(H=o[(xt+tt)%this._hashSize],!(H!==-1&&H!==s[H]));tt++);H=e[H];let I=H,z;for(;z=s[I],Z(B,$,t[2*I],t[2*I+1],t[2*z],t[2*z+1])>=0;)if(I=z,I===H){I=-1;break}if(I===-1)continue;let N=this._addTriangle(I,P,s[I],-1,-1,i[I]);i[P]=this._legalize(N+2),i[I]=N,C++;let j=s[I];for(;z=s[j],Z(B,$,t[2*j],t[2*j+1],t[2*z],t[2*z+1])<0;)N=this._addTriangle(j,P,z,i[P],-1,i[j]),i[P]=this._legalize(N+2),s[j]=j,C--,j=z;if(I===H)for(;z=e[I],Z(B,$,t[2*z],t[2*z+1],t[2*I],t[2*I+1])<0;)N=this._addTriangle(z,P,I,-1,i[I],i[z]),this._legalize(N+2),i[z]=N,s[I]=I,C--,I=z;this._hullStart=e[P]=I,s[I]=e[j]=P,s[P]=j,o[this._hashKey(B,$)]=P,o[this._hashKey(t[2*I],t[2*I+1])]=I}this.hull=new Uint32Array(C);for(let y=0,v=this._hullStart;y<C;y++)this.hull[y]=v,v=s[v];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,e){return Math.floor(jt(t-this._cx,e-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:e,_halfedges:s,coords:i}=this;let o=0,l=0;for(;;){const a=s[t],n=t-t%3;if(l=n+(t+2)%3,a===-1){if(o===0)break;t=D[--o];continue}const r=a-a%3,d=n+(t+1)%3,u=r+(a+2)%3,h=e[l],c=e[t],m=e[d],g=e[u];if(Gt(i[2*h],i[2*h+1],i[2*c],i[2*c+1],i[2*m],i[2*m+1],i[2*g],i[2*g+1])){e[t]=g,e[a]=h;const p=s[u];if(p===-1){let b=this._hullStart;do{if(this._hullTri[b]===u){this._hullTri[b]=t;break}b=this._hullPrev[b]}while(b!==this._hullStart)}this._link(t,p),this._link(a,s[l]),this._link(l,u);const x=r+(a+1)%3;o<D.length&&(D[o++]=x)}else{if(o===0)break;t=D[--o]}}return l}_link(t,e){this._halfedges[t]=e,e!==-1&&(this._halfedges[e]=t)}_addTriangle(t,e,s,i,o,l){const a=this.trianglesLen;return this._triangles[a]=t,this._triangles[a+1]=e,this._triangles[a+2]=s,this._link(a,i),this._link(a+1,o),this._link(a+2,l),this.trianglesLen+=3,a}}function jt(f,t){const e=f/(Math.abs(f)+Math.abs(t));return(t>0?3-e:1+e)/4}function nt(f,t,e,s){const i=f-e,o=t-s;return i*i+o*o}function Gt(f,t,e,s,i,o,l,a){const n=f-l,r=t-a,d=e-l,u=s-a,h=i-l,c=o-a,m=n*n+r*r,g=d*d+u*u,_=h*h+c*c;return n*(u*_-g*c)-r*(d*_-g*h)+m*(d*c-u*h)<0}function Ot(f,t,e,s,i,o){const l=e-f,a=s-t,n=i-f,r=o-t,d=l*l+a*a,u=n*n+r*r,h=.5/(l*r-a*n),c=(r*d-a*u)*h,m=(l*u-n*d)*h;return c*c+m*m}function Nt(f,t,e,s,i,o){const l=e-f,a=s-t,n=i-f,r=o-t,d=l*l+a*a,u=n*n+r*r,h=.5/(l*r-a*n),c=f+(r*d-a*u)*h,m=t+(l*u-n*d)*h;return{x:c,y:m}}function X(f,t,e,s){if(s-e<=20)for(let i=e+1;i<=s;i++){const o=f[i],l=t[o];let a=i-1;for(;a>=e&&t[f[a]]>l;)f[a+1]=f[a--];f[a+1]=o}else{const i=e+s>>1;let o=e+1,l=s;Y(f,i,o),t[f[e]]>t[f[s]]&&Y(f,e,s),t[f[o]]>t[f[s]]&&Y(f,o,s),t[f[e]]>t[f[o]]&&Y(f,e,o);const a=f[o],n=t[a];for(;;){do o++;while(t[f[o]]<n);do l--;while(t[f[l]]>n);if(l<o)break;Y(f,o,l)}f[e+1]=f[l],f[l]=a,s-o+1>=l-e?(X(f,t,o,s),X(f,t,e,l-1)):(X(f,t,e,l-1),X(f,t,o,s))}}function Y(f,t,e){const s=f[t];f[t]=f[e],f[e]=s}function Ut(f){return f[0]}function Vt(f){return f[1]}const ht=1e-6;class U{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(t,e){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+e}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(t,e){this._+=`L${this._x1=+t},${this._y1=+e}`}arc(t,e,s){t=+t,e=+e,s=+s;const i=t+s,o=e;if(s<0)throw new Error("negative radius");this._x1===null?this._+=`M${i},${o}`:(Math.abs(this._x1-i)>ht||Math.abs(this._y1-o)>ht)&&(this._+="L"+i+","+o),s&&(this._+=`A${s},${s},0,1,1,${t-s},${e}A${s},${s},0,1,1,${this._x1=i},${this._y1=o}`)}rect(t,e,s,i){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+e}h${+s}v${+i}h${-s}Z`}value(){return this._||null}}class it{constructor(){this._=[]}moveTo(t,e){this._.push([t,e])}closePath(){this._.push(this._[0].slice())}lineTo(t,e){this._.push([t,e])}value(){return this._.length?this._:null}}class Rt{constructor(t,[e,s,i,o]=[0,0,960,500]){if(!((i=+i)>=(e=+e))||!((o=+o)>=(s=+s)))throw new Error("invalid bounds");this.delaunay=t,this._circumcenters=new Float64Array(t.points.length*2),this.vectors=new Float64Array(t.points.length*2),this.xmax=i,this.xmin=e,this.ymax=o,this.ymin=s,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:t,hull:e,triangles:s},vectors:i}=this,o=this.circumcenters=this._circumcenters.subarray(0,s.length/3*2);for(let c=0,m=0,g=s.length,_,p;c<g;c+=3,m+=2){const x=s[c]*2,b=s[c+1]*2,T=s[c+2]*2,w=t[x],A=t[x+1],E=t[b],M=t[b+1],C=t[T],y=t[T+1],v=E-w,S=M-A,P=C-w,B=y-A,$=(v*B-S*P)*2;if(Math.abs($)<1e-9){let H=1e9;const I=s[0]*2;H*=Math.sign((t[I]-w)*B-(t[I+1]-A)*P),_=(w+C)/2-H*B,p=(A+y)/2+H*P}else{const H=1/$,I=v*v+S*S,z=P*P+B*B;_=w+(B*I-S*z)*H,p=A+(v*z-P*I)*H}o[m]=_,o[m+1]=p}let l=e[e.length-1],a,n=l*4,r,d=t[2*l],u,h=t[2*l+1];i.fill(0);for(let c=0;c<e.length;++c)l=e[c],a=n,r=d,u=h,n=l*4,d=t[2*l],h=t[2*l+1],i[a+2]=i[n]=u-h,i[a+3]=i[n+1]=d-r}render(t){const e=t==null?t=new U:void 0,{delaunay:{halfedges:s,inedges:i,hull:o},circumcenters:l,vectors:a}=this;if(o.length<=1)return null;for(let d=0,u=s.length;d<u;++d){const h=s[d];if(h<d)continue;const c=Math.floor(d/3)*2,m=Math.floor(h/3)*2,g=l[c],_=l[c+1],p=l[m],x=l[m+1];this._renderSegment(g,_,p,x,t)}let n,r=o[o.length-1];for(let d=0;d<o.length;++d){n=r,r=o[d];const u=Math.floor(i[r]/3)*2,h=l[u],c=l[u+1],m=n*4,g=this._project(h,c,a[m+2],a[m+3]);g&&this._renderSegment(h,c,g[0],g[1],t)}return e&&e.value()}renderBounds(t){const e=t==null?t=new U:void 0;return t.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),e&&e.value()}renderCell(t,e){const s=e==null?e=new U:void 0,i=this._clip(t);if(i===null||!i.length)return;e.moveTo(i[0],i[1]);let o=i.length;for(;i[0]===i[o-2]&&i[1]===i[o-1]&&o>1;)o-=2;for(let l=2;l<o;l+=2)(i[l]!==i[l-2]||i[l+1]!==i[l-1])&&e.lineTo(i[l],i[l+1]);return e.closePath(),s&&s.value()}*cellPolygons(){const{delaunay:{points:t}}=this;for(let e=0,s=t.length/2;e<s;++e){const i=this.cellPolygon(e);i&&(i.index=e,yield i)}}cellPolygon(t){const e=new it;return this.renderCell(t,e),e.value()}_renderSegment(t,e,s,i,o){let l;const a=this._regioncode(t,e),n=this._regioncode(s,i);a===0&&n===0?(o.moveTo(t,e),o.lineTo(s,i)):(l=this._clipSegment(t,e,s,i,a,n))&&(o.moveTo(l[0],l[1]),o.lineTo(l[2],l[3]))}contains(t,e,s){return e=+e,e!==e||(s=+s,s!==s)?!1:this.delaunay._step(t,e,s)===t}*neighbors(t){const e=this._clip(t);if(e)for(const s of this.delaunay.neighbors(t)){const i=this._clip(s);if(i){t:for(let o=0,l=e.length;o<l;o+=2)for(let a=0,n=i.length;a<n;a+=2)if(e[o]==i[a]&&e[o+1]==i[a+1]&&e[(o+2)%l]==i[(a+n-2)%n]&&e[(o+3)%l]==i[(a+n-1)%n]){yield s;break t}}}}_cell(t){const{circumcenters:e,delaunay:{inedges:s,halfedges:i,triangles:o}}=this,l=s[t];if(l===-1)return null;const a=[];let n=l;do{const r=Math.floor(n/3);if(a.push(e[r*2],e[r*2+1]),n=n%3===2?n-2:n+1,o[n]!==t)break;n=i[n]}while(n!==l&&n!==-1);return a}_clip(t){if(t===0&&this.delaunay.hull.length===1)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const e=this._cell(t);if(e===null)return null;const{vectors:s}=this,i=t*4;return s[i]||s[i+1]?this._clipInfinite(t,e,s[i],s[i+1],s[i+2],s[i+3]):this._clipFinite(t,e)}_clipFinite(t,e){const s=e.length;let i=null,o,l,a=e[s-2],n=e[s-1],r,d=this._regioncode(a,n),u,h=0;for(let c=0;c<s;c+=2)if(o=a,l=n,a=e[c],n=e[c+1],r=d,d=this._regioncode(a,n),r===0&&d===0)u=h,h=0,i?i.push(a,n):i=[a,n];else{let m,g,_,p,x;if(r===0){if((m=this._clipSegment(o,l,a,n,r,d))===null)continue;[g,_,p,x]=m}else{if((m=this._clipSegment(a,n,o,l,d,r))===null)continue;[p,x,g,_]=m,u=h,h=this._edgecode(g,_),u&&h&&this._edge(t,u,h,i,i.length),i?i.push(g,_):i=[g,_]}u=h,h=this._edgecode(p,x),u&&h&&this._edge(t,u,h,i,i.length),i?i.push(p,x):i=[p,x]}if(i)u=h,h=this._edgecode(i[0],i[1]),u&&h&&this._edge(t,u,h,i,i.length);else if(this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return i}_clipSegment(t,e,s,i,o,l){for(;;){if(o===0&&l===0)return[t,e,s,i];if(o&l)return null;let a,n,r=o||l;r&8?(a=t+(s-t)*(this.ymax-e)/(i-e),n=this.ymax):r&4?(a=t+(s-t)*(this.ymin-e)/(i-e),n=this.ymin):r&2?(n=e+(i-e)*(this.xmax-t)/(s-t),a=this.xmax):(n=e+(i-e)*(this.xmin-t)/(s-t),a=this.xmin),o?(t=a,e=n,o=this._regioncode(t,e)):(s=a,i=n,l=this._regioncode(s,i))}}_clipInfinite(t,e,s,i,o,l){let a=Array.from(e),n;if((n=this._project(a[0],a[1],s,i))&&a.unshift(n[0],n[1]),(n=this._project(a[a.length-2],a[a.length-1],o,l))&&a.push(n[0],n[1]),a=this._clipFinite(t,a))for(let r=0,d=a.length,u,h=this._edgecode(a[d-2],a[d-1]);r<d;r+=2)u=h,h=this._edgecode(a[r],a[r+1]),u&&h&&(r=this._edge(t,u,h,a,r),d=a.length);else this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(a=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return a}_edge(t,e,s,i,o){for(;e!==s;){let l,a;switch(e){case 5:e=4;continue;case 4:e=6,l=this.xmax,a=this.ymin;break;case 6:e=2;continue;case 2:e=10,l=this.xmax,a=this.ymax;break;case 10:e=8;continue;case 8:e=9,l=this.xmin,a=this.ymax;break;case 9:e=1;continue;case 1:e=5,l=this.xmin,a=this.ymin;break}(i[o]!==l||i[o+1]!==a)&&this.contains(t,l,a)&&(i.splice(o,0,l,a),o+=2)}if(i.length>4)for(let l=0;l<i.length;l+=2){const a=(l+2)%i.length,n=(l+4)%i.length;(i[l]===i[a]&&i[a]===i[n]||i[l+1]===i[a+1]&&i[a+1]===i[n+1])&&(i.splice(a,2),l-=2)}return o}_project(t,e,s,i){let o=1/0,l,a,n;if(i<0){if(e<=this.ymin)return null;(l=(this.ymin-e)/i)<o&&(n=this.ymin,a=t+(o=l)*s)}else if(i>0){if(e>=this.ymax)return null;(l=(this.ymax-e)/i)<o&&(n=this.ymax,a=t+(o=l)*s)}if(s>0){if(t>=this.xmax)return null;(l=(this.xmax-t)/s)<o&&(a=this.xmax,n=e+(o=l)*i)}else if(s<0){if(t<=this.xmin)return null;(l=(this.xmin-t)/s)<o&&(a=this.xmin,n=e+(o=l)*i)}return[a,n]}_edgecode(t,e){return(t===this.xmin?1:t===this.xmax?2:0)|(e===this.ymin?4:e===this.ymax?8:0)}_regioncode(t,e){return(t<this.xmin?1:t>this.xmax?2:0)|(e<this.ymin?4:e>this.ymax?8:0)}}const Xt=2*Math.PI,R=Math.pow;function Yt(f){return f[0]}function qt(f){return f[1]}function Zt(f){const{triangles:t,coords:e}=f;for(let s=0;s<t.length;s+=3){const i=2*t[s],o=2*t[s+1],l=2*t[s+2];if((e[l]-e[i])*(e[o+1]-e[i+1])-(e[o]-e[i])*(e[l+1]-e[i+1])>1e-10)return!1}return!0}function Dt(f,t,e){return[f+Math.sin(f+t)*e,t+Math.cos(f-t)*e]}class _t{static from(t,e=Yt,s=qt,i){return new _t("length"in t?Kt(t,e,s,i):Float64Array.from(Qt(t,e,s,i)))}constructor(t){this._delaunator=new W(t),this.inedges=new Int32Array(t.length/2),this._hullIndex=new Int32Array(t.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const t=this._delaunator,e=this.points;if(t.hull&&t.hull.length>2&&Zt(t)){this.collinear=Int32Array.from({length:e.length/2},(h,c)=>c).sort((h,c)=>e[2*h]-e[2*c]||e[2*h+1]-e[2*c+1]);const n=this.collinear[0],r=this.collinear[this.collinear.length-1],d=[e[2*n],e[2*n+1],e[2*r],e[2*r+1]],u=1e-8*Math.hypot(d[3]-d[1],d[2]-d[0]);for(let h=0,c=e.length/2;h<c;++h){const m=Dt(e[2*h],e[2*h+1],u);e[2*h]=m[0],e[2*h+1]=m[1]}this._delaunator=new W(e)}else delete this.collinear;const s=this.halfedges=this._delaunator.halfedges,i=this.hull=this._delaunator.hull,o=this.triangles=this._delaunator.triangles,l=this.inedges.fill(-1),a=this._hullIndex.fill(-1);for(let n=0,r=s.length;n<r;++n){const d=o[n%3===2?n-2:n+1];(s[n]===-1||l[d]===-1)&&(l[d]=n)}for(let n=0,r=i.length;n<r;++n)a[i[n]]=n;i.length<=2&&i.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=i[0],l[i[0]]=1,i.length===2&&(l[i[1]]=0,this.triangles[1]=i[1],this.triangles[2]=i[1]))}voronoi(t){return new Rt(this,t)}*neighbors(t){const{inedges:e,hull:s,_hullIndex:i,halfedges:o,triangles:l,collinear:a}=this;if(a){const u=a.indexOf(t);u>0&&(yield a[u-1]),u<a.length-1&&(yield a[u+1]);return}const n=e[t];if(n===-1)return;let r=n,d=-1;do{if(yield d=l[r],r=r%3===2?r-2:r+1,l[r]!==t)return;if(r=o[r],r===-1){const u=s[(i[t]+1)%s.length];u!==d&&(yield u);return}}while(r!==n)}find(t,e,s=0){if(t=+t,t!==t||(e=+e,e!==e))return-1;const i=s;let o;for(;(o=this._step(s,t,e))>=0&&o!==s&&o!==i;)s=o;return o}_step(t,e,s){const{inedges:i,hull:o,_hullIndex:l,halfedges:a,triangles:n,points:r}=this;if(i[t]===-1||!r.length)return(t+1)%(r.length>>1);let d=t,u=R(e-r[t*2],2)+R(s-r[t*2+1],2);const h=i[t];let c=h;do{let m=n[c];const g=R(e-r[m*2],2)+R(s-r[m*2+1],2);if(g<u&&(u=g,d=m),c=c%3===2?c-2:c+1,n[c]!==t)break;if(c=a[c],c===-1){if(c=o[(l[t]+1)%o.length],c!==m&&R(e-r[c*2],2)+R(s-r[c*2+1],2)<u)return c;break}}while(c!==h);return d}render(t){const e=t==null?t=new U:void 0,{points:s,halfedges:i,triangles:o}=this;for(let l=0,a=i.length;l<a;++l){const n=i[l];if(n<l)continue;const r=o[l]*2,d=o[n]*2;t.moveTo(s[r],s[r+1]),t.lineTo(s[d],s[d+1])}return this.renderHull(t),e&&e.value()}renderPoints(t,e){e===void 0&&(!t||typeof t.moveTo!="function")&&(e=t,t=null),e=e==null?2:+e;const s=t==null?t=new U:void 0,{points:i}=this;for(let o=0,l=i.length;o<l;o+=2){const a=i[o],n=i[o+1];t.moveTo(a+e,n),t.arc(a,n,e,0,Xt)}return s&&s.value()}renderHull(t){const e=t==null?t=new U:void 0,{hull:s,points:i}=this,o=s[0]*2,l=s.length;t.moveTo(i[o],i[o+1]);for(let a=1;a<l;++a){const n=2*s[a];t.lineTo(i[n],i[n+1])}return t.closePath(),e&&e.value()}hullPolygon(){const t=new it;return this.renderHull(t),t.value()}renderTriangle(t,e){const s=e==null?e=new U:void 0,{points:i,triangles:o}=this,l=o[t*=3]*2,a=o[t+1]*2,n=o[t+2]*2;return e.moveTo(i[l],i[l+1]),e.lineTo(i[a],i[a+1]),e.lineTo(i[n],i[n+1]),e.closePath(),s&&s.value()}*trianglePolygons(){const{triangles:t}=this;for(let e=0,s=t.length/3;e<s;++e)yield this.trianglePolygon(e)}trianglePolygon(t){const e=new it;return this.renderTriangle(t,e),e.value()}}function Kt(f,t,e,s){const i=f.length,o=new Float64Array(i*2);for(let l=0;l<i;++l){const a=f[l];o[l*2]=t.call(s,a,l,f),o[l*2+1]=e.call(s,a,l,f)}return o}function*Qt(f,t,e,s){let i=0;for(const o of f)yield t.call(s,o,i,f),yield e.call(s,o,i,f),++i}var Wt=function(){var f=0,t=1,e=new G;function s(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new a,this.unassigned=new a,this.vertices=[]}Object.assign(s.prototype,{toJSON:function(){const n=this.faces.map(c=>c.toArray()),r=Array.from(new Set(n.flat())).sort(),d=[];for(let c=0;c<r.length;c++)d.push(this.vertices[r[c]].point.x,this.vertices[r[c]].point.y,this.vertices[r[c]].point.z);const u=new Map;for(let c=0;c<r.length;c++)u.set(r[c],c);const h=[];for(let c=0;c<n.length;c++)h.push([u.get(n[c][0]),u.get(n[c][1]),u.get(n[c][2])]);return[d,h]},setFromPoints:function(n){Array.isArray(n)!==!0&&console.error("THREE.ConvexHull: Points parameter is not an array."),n.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(var r=0,d=n.length;r<d;r++)this.vertices.push(new l(n[r],r));return this.compute(),this},setFromObject:function(n){var r=[];return n.updateMatrixWorld(!0),n.traverse(function(d){var u,h,c,m=d.geometry;if(m!==void 0&&(m.isGeometry&&(m=m.toBufferGeometry?m.toBufferGeometry():new BufferGeometry().fromGeometry(m)),m.isBufferGeometry)){var g=m.attributes.position;if(g!==void 0)for(u=0,h=g.count;u<h;u++)c=new G,c.fromBufferAttribute(g,u).applyMatrix4(d.matrixWorld),r.push(c)}}),this.setFromPoints(r)},containsPoint:function(n){for(var r=this.faces,d=0,u=r.length;d<u;d++){var h=r[d];if(h.distanceToPoint(n)>this.tolerance)return!1}return!0},intersectRay:function(n,r){for(var d=this.faces,u=-1/0,h=1/0,c=0,m=d.length;c<m;c++){var g=d[c],_=g.distanceToPoint(n.origin),p=g.normal.dot(n.direction);if(_>0&&p>=0)return null;var x=p!==0?-_/p:0;if(!(x<=0)&&(p>0?h=Math.min(x,h):u=Math.max(x,u),u>h))return null}return u!==-1/0?n.at(u,r):n.at(h,r),r},intersectsRay:function(n){return this.intersectRay(n,e)!==null},makeEmpty:function(){return this.faces=[],this.vertices=[],this},addVertexToFace:function(n,r){return n.face=r,r.outside===null?this.assigned.append(n):this.assigned.insertBefore(r.outside,n),r.outside=n,this},removeVertexFromFace:function(n,r){return n===r.outside&&(n.next!==null&&n.next.face===r?r.outside=n.next:r.outside=null),this.assigned.remove(n),this},removeAllVerticesFromFace:function(n){if(n.outside!==null){for(var r=n.outside,d=n.outside;d.next!==null&&d.next.face===n;)d=d.next;return this.assigned.removeSubList(r,d),r.prev=d.next=null,n.outside=null,r}},deleteFaceVertices:function(n,r){var d=this.removeAllVerticesFromFace(n);if(d!==void 0)if(r===void 0)this.unassigned.appendChain(d);else{var u=d;do{var h=u.next,c=r.distanceToPoint(u.point);c>this.tolerance?this.addVertexToFace(u,r):this.unassigned.append(u),u=h}while(u!==null)}return this},resolveUnassignedPoints:function(n){if(this.unassigned.isEmpty()===!1){var r=this.unassigned.first();do{for(var d=r.next,u=this.tolerance,h=null,c=0;c<n.length;c++){var m=n[c];if(m.mark===f){var g=m.distanceToPoint(r.point);if(g>u&&(u=g,h=m),u>1e3*this.tolerance)break}}h!==null&&this.addVertexToFace(r,h),r=d}while(r!==null)}return this},computeExtremes:function(){var n=new G,r=new G,d=[],u=[],h,c,m;for(h=0;h<3;h++)d[h]=u[h]=this.vertices[0];for(n.copy(this.vertices[0].point),r.copy(this.vertices[0].point),h=0,c=this.vertices.length;h<c;h++){var g=this.vertices[h],_=g.point;for(m=0;m<3;m++)_.getComponent(m)<n.getComponent(m)&&(n.setComponent(m,_.getComponent(m)),d[m]=g);for(m=0;m<3;m++)_.getComponent(m)>r.getComponent(m)&&(r.setComponent(m,_.getComponent(m)),u[m]=g)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(n.x),Math.abs(r.x))+Math.max(Math.abs(n.y),Math.abs(r.y))+Math.max(Math.abs(n.z),Math.abs(r.z))),{min:d,max:u}},computeInitialHull:function(){var n,r,d;return function(){n===void 0&&(n=new At,r=new Pt,d=new G);var h,c=this.vertices,m=this.computeExtremes(),g=m.min,_=m.max,p,x,b,T,w,A,E,M,C=0,y=0;for(w=0;w<3;w++)M=_[w].point.getComponent(w)-g[w].point.getComponent(w),M>C&&(C=M,y=w);for(p=g[y],x=_[y],C=0,n.set(p.point,x.point),w=0,A=this.vertices.length;w<A;w++)h=c[w],h!==p&&h!==x&&(n.closestPointToPoint(h.point,!0,d),M=d.distanceToSquared(h.point),M>C&&(C=M,b=h));for(C=-1,r.setFromCoplanarPoints(p.point,x.point,b.point),w=0,A=this.vertices.length;w<A;w++)h=c[w],h!==p&&h!==x&&h!==b&&(M=Math.abs(r.distanceToPoint(h.point)),M>C&&(C=M,T=h));var v=[];if(r.distanceToPoint(T.point)<0)for(v.push(i.create(p,x,b),i.create(T,x,p),i.create(T,b,x),i.create(T,p,b)),w=0;w<3;w++)E=(w+1)%3,v[w+1].getEdge(2).setTwin(v[0].getEdge(E)),v[w+1].getEdge(1).setTwin(v[E+1].getEdge(0));else for(v.push(i.create(p,b,x),i.create(T,p,x),i.create(T,x,b),i.create(T,b,p)),w=0;w<3;w++)E=(w+1)%3,v[w+1].getEdge(2).setTwin(v[0].getEdge((3-w)%3)),v[w+1].getEdge(0).setTwin(v[E+1].getEdge(1));for(w=0;w<4;w++)this.faces.push(v[w]);for(w=0,A=c.length;w<A;w++)if(h=c[w],h!==p&&h!==x&&h!==b&&h!==T){C=this.tolerance;var S=null;for(E=0;E<4;E++)M=this.faces[E].distanceToPoint(h.point),M>C&&(C=M,S=this.faces[E]);S!==null&&this.addVertexToFace(h,S)}return this}}(),reindexFaces:function(){for(var n=[],r=0;r<this.faces.length;r++){var d=this.faces[r];d.mark===f&&n.push(d)}return this.faces=n,this},nextVertexToAdd:function(){if(this.assigned.isEmpty()===!1){var n,r=0,d=this.assigned.first().face,u=d.outside;do{var h=d.distanceToPoint(u.point);h>r&&(r=h,n=u),u=u.next}while(u!==null&&u.face===d);return n}},computeHorizon:function(n,r,d,u){this.deleteFaceVertices(d),d.mark=t;var h;r===null?h=r=d.getEdge(0):h=r.next;do{var c=h.twin,m=c.face;m.mark===f&&(m.distanceToPoint(n)>this.tolerance?this.computeHorizon(n,c,m,u):u.push(h)),h=h.next}while(h!==r);return this},addAdjoiningFace:function(n,r){var d=i.create(n,r.tail(),r.head());return this.faces.push(d),d.getEdge(-1).setTwin(r.twin),d.getEdge(0)},addNewFaces:function(n,r){this.newFaces=[];for(var d=null,u=null,h=0;h<r.length;h++){var c=r[h],m=this.addAdjoiningFace(n,c);d===null?d=m:m.next.setTwin(u),this.newFaces.push(m.face),u=m}return d.next.setTwin(u),this},addVertexToHull:function(n){var r=[];return this.unassigned.clear(),this.removeVertexFromFace(n,n.face),this.computeHorizon(n.point,null,n.face,r),this.addNewFaces(n,r),this.resolveUnassignedPoints(this.newFaces),this},cleanup:function(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this},compute:function(){var n;for(this.computeInitialHull();(n=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(n);return this.reindexFaces(),this.cleanup(),this}});function i(){this.normal=new G,this.midpoint=new G,this.area=0,this.constant=0,this.outside=null,this.mark=f,this.edge=null}Object.assign(i,{create:function(n,r,d){var u=new i,h=new o(n,u),c=new o(r,u),m=new o(d,u);return h.next=m.prev=c,c.next=h.prev=m,m.next=c.prev=h,u.edge=h,u.compute()}}),Object.assign(i.prototype,{toArray:function(){const n=[];let r=this.edge;do n.push(r.head().index),r=r.next;while(r!==this.edge);return n},getEdge:function(n){for(var r=this.edge;n>0;)r=r.next,n--;for(;n<0;)r=r.prev,n++;return r},compute:function(){var n;return function(){n===void 0&&(n=new It);var d=this.edge.tail(),u=this.edge.head(),h=this.edge.next.head();return n.set(d.point,u.point,h.point),n.getNormal(this.normal),n.getMidpoint(this.midpoint),this.area=n.getArea(),this.constant=this.normal.dot(this.midpoint),this}}(),distanceToPoint:function(n){return this.normal.dot(n)-this.constant}});function o(n,r){this.vertex=n,this.prev=null,this.next=null,this.twin=null,this.face=r}Object.assign(o.prototype,{head:function(){return this.vertex},tail:function(){return this.prev?this.prev.vertex:null},length:function(){var n=this.head(),r=this.tail();return r!==null?r.point.distanceTo(n.point):-1},lengthSquared:function(){var n=this.head(),r=this.tail();return r!==null?r.point.distanceToSquared(n.point):-1},setTwin:function(n){return this.twin=n,n.twin=this,this}});function l(n,r){this.point=n,this.index=r,this.prev=null,this.next=null,this.face=null}function a(){this.head=null,this.tail=null}return Object.assign(a.prototype,{first:function(){return this.head},last:function(){return this.tail},clear:function(){return this.head=this.tail=null,this},insertBefore:function(n,r){return r.prev=n.prev,r.next=n,r.prev===null?this.head=r:r.prev.next=r,n.prev=r,this},insertAfter:function(n,r){return r.prev=n,r.next=n.next,r.next===null?this.tail=r:r.next.prev=r,n.next=r,this},append:function(n){return this.head===null?this.head=n:this.tail.next=n,n.prev=this.tail,n.next=null,this.tail=n,this},appendChain:function(n){for(this.head===null?this.head=n:this.tail.next=n,n.prev=this.tail;n.next!==null;)n=n.next;return this.tail=n,this},remove:function(n){return n.prev===null?this.head=n.next:n.prev.next=n.next,n.next===null?this.tail=n.prev:n.next.prev=n.prev,this},removeSubList:function(n,r){return n.prev===null?this.head=r.next:n.prev.next=r.next,r.next===null?this.tail=n.prev:r.next.prev=n.prev,this},isEmpty:function(){return this.head===null}}),s}();const Jt=new G,K=new G,te=new Ct;function J(f){const t=ne(f);if(t.length===0)return null;if(t.length===1)return ut(t[0]);let e;const s=[];for(;e=t.pop();)s.push(ie(ut(e)));return ee(s)}function ut(f){let t=f.geometry;return t.toBufferGeometry?t=t.toBufferGeometry():t=t.clone(),f.updateMatrixWorld(),f.matrixWorld.decompose(Jt,te,K),t.scale(K.x,K.y,K.z),t}function ee(f){let t=0;for(let i=0;i<f.length;i++){const o=f[i].attributes.position;o&&o.itemSize===3&&(t+=o.count)}const e=new Float32Array(t*3);let s=0;for(let i=0;i<f.length;i++){const o=f[i].attributes.position;if(o&&o.itemSize===3)for(let l=0;l<o.count;l++)e[s++]=o.getX(l),e[s++]=o.getY(l),e[s++]=o.getZ(l)}return new pt().setAttribute("position",new yt(e,3))}function wt(f){const t=f.attributes.position,e=new Float32Array(t.count*3);for(let s=0;s<t.count;s++)e[s*3]=t.getX(s),e[s*3+1]=t.getY(s),e[s*3+2]=t.getZ(s);return e}function ne(f){const t=[];return f.traverse(function(e){e.isMesh&&t.push(e)}),t}function Q(f,t){switch(t){case"x":return f.x;case"y":return f.y;case"z":return f.z}throw new Error(`Unexpected component ${t}`)}function ie(f,t=1e-4){t=Math.max(t,Number.EPSILON);const e={},s=f.getIndex(),i=f.getAttribute("position"),o=s?s.count:i.count;let l=0;const a=[],n=[],r=Math.log10(1/t),d=Math.pow(10,r);for(let c=0;c<o;c++){const m=s?s.getX(c):c;let g="";g+=`${~~(i.getX(m)*d)},`,g+=`${~~(i.getY(m)*d)},`,g+=`${~~(i.getZ(m)*d)},`,g in e?a.push(e[g]):(n.push(i.getX(m)),n.push(i.getY(m)),n.push(i.getZ(m)),e[g]=l,a.push(l),l++)}const u=new yt(new Float32Array(n),i.itemSize,i.normalized),h=new pt;return h.setAttribute("position",u),h.setIndex(a),h}const ct=Math.PI/2;var F;(function(f){f.BOX="Box",f.CYLINDER="Cylinder",f.SPHERE="Sphere",f.HULL="ConvexPolyhedron",f.MESH="Trimesh"})(F||(F={}));const se=function(t,e={}){let s;if(e.type===F.BOX)return dt(t);if(e.type===F.CYLINDER)return fe(t,e);if(e.type===F.SPHERE)return ge(t,e);if(e.type===F.HULL)return ue(t);if(e.type===F.MESH)return s=J(t),s?pe(s):null;if(e.type)throw new Error(`[CANNON.getShapeParameters] Invalid type "${e.type}".`);if(s=J(t),!s)return null;switch(s.type){case"BoxGeometry":case"BoxBufferGeometry":return ft(s);case"CylinderGeometry":case"CylinderBufferGeometry":return ce(s);case"PlaneGeometry":case"PlaneBufferGeometry":return de(s);case"SphereGeometry":case"SphereBufferGeometry":return me(s);case"TubeGeometry":case"BufferGeometry":return dt(t);default:return console.warn('Unrecognized geometry: "%s". Using bounding box as shape.',s.type),ft(s)}},we=function(t,e={}){const s=se(t,e);if(!s)return null;const{type:i,params:o,offset:l,orientation:a}=s;let n;return i===F.BOX?n=re(o):i===F.CYLINDER?n=oe(o):i===F.SPHERE?n=le(o):i===F.HULL?n=ae(o):n=he(o),{shape:n,offset:l,orientation:a}};function re(f){const{x:t,y:e,z:s}=f;return new vt(new st(t,e,s))}function oe(f){const{radiusTop:t,radiusBottom:e,height:s,segments:i}=f,o=new bt(t,e,s,i);return o.radiusTop=e,o.radiusBottom=e,o.height=s,o.numSegments=i,o}function le(f){return new Tt(f.radius)}function ae(f){const{faces:t,vertices:e}=f,s=[];for(let o=0;o<e.length;o+=3)s.push(new st(e[o],e[o+1],e[o+2]));return new St({faces:t,vertices:s})}function he(f){const{vertices:t,indices:e}=f;return new Mt(t,e)}function ft(f){if(!wt(f).length)return null;f.computeBoundingBox();const e=f.boundingBox;return{type:F.BOX,params:{x:(e.max.x-e.min.x)/2,y:(e.max.y-e.min.y)/2,z:(e.max.z-e.min.z)/2}}}function dt(f){const t=f.clone();t.quaternion.set(0,0,0,1),t.updateMatrixWorld();const e=new gt().setFromObject(t);if(!isFinite(e.min.lengthSq()))return null;const s=e.translate(t.position.negate()).getCenter(new G);return{type:F.BOX,params:{x:(e.max.x-e.min.x)/2,y:(e.max.y-e.min.y)/2,z:(e.max.z-e.min.z)/2},offset:s.lengthSq()?new st(s.x,s.y,s.z):void 0}}function ue(f){const t=J(f);if(!t)return null;const e=1e-4;for(let o=0;o<t.attributes.position.count;o++)t.attributes.position.setXYZ(o,t.attributes.position.getX(o)+(Math.random()-.5)*e,t.attributes.position.getY(o)+(Math.random()-.5)*e,t.attributes.position.getZ(o)+(Math.random()-.5)*e);const[s,i]=new Wt().setFromObject(new Et(t)).toJSON();return{type:F.HULL,params:{vertices:new Float32Array(s),faces:i}}}function ce(f){const t=f.parameters;return{type:F.CYLINDER,params:{radiusTop:t.radiusTop,radiusBottom:t.radiusBottom,height:t.height,segments:t.radialSegments},orientation:new mt().setFromEuler(Bt.degToRad(-90),0,0,"XYZ").normalize()}}function fe(f,t){const e=["x","y","z"],s=t.cylinderAxis||"y",i=e.splice(e.indexOf(s),1)&&e,o=new gt().setFromObject(f);if(!isFinite(o.min.lengthSq()))return null;const l=o.max[s]-o.min[s],a=.5*Math.max(Q(o.max,i[0])-Q(o.min,i[0]),Q(o.max,i[1])-Q(o.min,i[1])),n=s==="y"?ct:0,r=s==="z"?ct:0;return{type:F.CYLINDER,params:{radiusTop:a,radiusBottom:a,height:l,segments:12},orientation:new mt().setFromEuler(n,r,0,"XYZ").normalize()}}function de(f){f.computeBoundingBox();const t=f.boundingBox;return{type:F.BOX,params:{x:(t.max.x-t.min.x)/2||.1,y:(t.max.y-t.min.y)/2||.1,z:(t.max.z-t.min.z)/2||.1}}}function me(f){return{type:F.SPHERE,params:{radius:f.parameters.radius}}}function ge(f,t){if(t.sphereRadius)return{type:F.SPHERE,params:{radius:t.sphereRadius}};const e=J(f);return e?(e.computeBoundingSphere(),{type:F.SPHERE,params:{radius:e.boundingSphere.radius}}):null}function pe(f){const t=wt(f);if(!t.length)return null;const e=new Uint32Array(t.length);for(let s=0;s<t.length;s++)e[s]=s;return{type:F.MESH,params:{vertices:t,indices:e}}}export{_t as D,F as S,we as t};
