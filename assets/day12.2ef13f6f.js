var $=Object.defineProperty;var Z=(f,e,t)=>e in f?$(f,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):f[e]=t;var d=(f,e,t)=>(Z(f,typeof e!="symbol"?e+"":e,t),t);import{d as _,v as J,M as v,l as w,L as K,w as ee,x as te,y as M,z as A,H as se,J as ne,K as j,t as ie,S as X,e as oe,c as re,i as ae,j as le,k as ce,X as R,Y as I,B as L,Z as D,_ as he,P as de,O as ue,W as pe,s as me}from"./three.module.9352233f.js";import{P as Q,B as U,D as fe,t as we,V as S,Q as ge,S as ye,a as xe,C as ve,b as be,T as Ee,H as Pe,c as y,W as Te}from"./three-to-cannon.modern.79be1cd4.js";import{O as Me}from"./OrbitControls.e80330a0.js";import"./stats.min.46d05fb3.js";import{F as Fe}from"./FXAAShader.0b4b74a1.js";class Ce{constructor(){d(this,"ui");d(this,"stats")}begin(){this.stats&&this.stats.begin()}end(){this.stats&&this.stats.end()}}class ze{constructor(){const e=new F,t=e.scene,s=e.physics,i=new _(100,100),n=new J({}),r=new v(i,n);r.receiveShadow=!0,r.rotateX(-Math.PI*.5),r.position.y=-3,t.add(r);const o=new Q,a=new U({mass:0});a.addShape(o),s.addBody(a),a.position.set(r.position.x,r.position.y,r.position.z),a.quaternion.set(r.quaternion.x,r.quaternion.y,r.quaternion.z,r.quaternion.w)}}const z=0,_e=1,Se=new w,O=new K,V=new ee,B=new w,C=new te;class W{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new N,this.unassigned=new N,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.vertices.push(new Ve(e[t]));this.compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(s){const i=s.geometry;if(i!==void 0){const n=i.attributes.position;if(n!==void 0)for(let r=0,o=n.count;r<o;r++){const a=new w;a.fromBufferAttribute(n,r).applyMatrix4(s.matrixWorld),t.push(a)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let s=0,i=t.length;s<i;s++)if(t[s].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const s=this.faces;let i=-1/0,n=1/0;for(let r=0,o=s.length;r<o;r++){const a=s[r],h=a.distanceToPoint(e.origin),l=a.normal.dot(e.direction);if(h>0&&l>=0)return null;const u=l!==0?-h/l:0;if(!(u<=0)&&(l>0?n=Math.min(u,n):i=Math.max(u,i),i>n))return null}return i!==-1/0?e.at(i,t):e.at(n,t),t}intersectsRay(e){return this.intersectRay(e,Se)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let s=e.outside;for(;s.next!==null&&s.next.face===e;)s=s.next;return this.assigned.removeSubList(t,s),t.prev=s.next=null,e.outside=null,t}}deleteFaceVertices(e,t){const s=this.removeAllVerticesFromFace(e);if(s!==void 0)if(t===void 0)this.unassigned.appendChain(s);else{let i=s;do{const n=i.next;t.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,t):this.unassigned.append(i),i=n}while(i!==null)}return this}resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const s=t.next;let i=this.tolerance,n=null;for(let r=0;r<e.length;r++){const o=e[r];if(o.mark===z){const a=o.distanceToPoint(t.point);if(a>i&&(i=a,n=o),i>1e3*this.tolerance)break}}n!==null&&this.addVertexToFace(t,n),t=s}while(t!==null)}return this}computeExtremes(){const e=new w,t=new w,s=[],i=[];for(let n=0;n<3;n++)s[n]=i[n]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let n=0,r=this.vertices.length;n<r;n++){const o=this.vertices[n],a=o.point;for(let h=0;h<3;h++)a.getComponent(h)<e.getComponent(h)&&(e.setComponent(h,a.getComponent(h)),s[h]=o);for(let h=0;h<3;h++)a.getComponent(h)>t.getComponent(h)&&(t.setComponent(h,a.getComponent(h)),i[h]=o)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:s,max:i}}computeInitialHull(){const e=this.vertices,t=this.computeExtremes(),s=t.min,i=t.max;let n=0,r=0;for(let c=0;c<3;c++){const p=i[c].point.getComponent(c)-s[c].point.getComponent(c);p>n&&(n=p,r=c)}const o=s[r],a=i[r];let h,l;n=0,O.set(o.point,a.point);for(let c=0,p=this.vertices.length;c<p;c++){const m=e[c];if(m!==o&&m!==a){O.closestPointToPoint(m.point,!0,B);const g=B.distanceToSquared(m.point);g>n&&(n=g,h=m)}}n=-1,V.setFromCoplanarPoints(o.point,a.point,h.point);for(let c=0,p=this.vertices.length;c<p;c++){const m=e[c];if(m!==o&&m!==a&&m!==h){const g=Math.abs(V.distanceToPoint(m.point));g>n&&(n=g,l=m)}}const u=[];if(V.distanceToPoint(l.point)<0){u.push(x.create(o,a,h),x.create(l,a,o),x.create(l,h,a),x.create(l,o,h));for(let c=0;c<3;c++){const p=(c+1)%3;u[c+1].getEdge(2).setTwin(u[0].getEdge(p)),u[c+1].getEdge(1).setTwin(u[p+1].getEdge(0))}}else{u.push(x.create(o,h,a),x.create(l,o,a),x.create(l,a,h),x.create(l,h,o));for(let c=0;c<3;c++){const p=(c+1)%3;u[c+1].getEdge(2).setTwin(u[0].getEdge((3-c)%3)),u[c+1].getEdge(0).setTwin(u[p+1].getEdge(1))}}for(let c=0;c<4;c++)this.faces.push(u[c]);for(let c=0,p=e.length;c<p;c++){const m=e[c];if(m!==o&&m!==a&&m!==h&&m!==l){n=this.tolerance;let g=null;for(let P=0;P<4;P++){const E=this.faces[P].distanceToPoint(m.point);E>n&&(n=E,g=this.faces[P])}g!==null&&this.addVertexToFace(m,g)}}return this}reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const s=this.faces[t];s.mark===z&&e.push(s)}return this.faces=e,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const s=this.assigned.first().face;let i=s.outside;do{const n=s.distanceToPoint(i.point);n>t&&(t=n,e=i),i=i.next}while(i!==null&&i.face===s);return e}}computeHorizon(e,t,s,i){this.deleteFaceVertices(s),s.mark=_e;let n;t===null?n=t=s.getEdge(0):n=t.next;do{const r=n.twin,o=r.face;o.mark===z&&(o.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,r,o,i):i.push(n)),n=n.next}while(n!==t);return this}addAdjoiningFace(e,t){const s=x.create(e,t.tail(),t.head());return this.faces.push(s),s.getEdge(-1).setTwin(t.twin),s.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let s=null,i=null;for(let n=0;n<t.length;n++){const r=t[n],o=this.addAdjoiningFace(e,r);s===null?s=o:o.next.setTwin(i),this.newFaces.push(o.face),i=o}return s.next.setTwin(i),this}addVertexToHull(e){const t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let e;for(this.computeInitialHull();(e=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}class x{constructor(){this.normal=new w,this.midpoint=new w,this.area=0,this.constant=0,this.outside=null,this.mark=z,this.edge=null}static create(e,t,s){const i=new x,n=new H(e,i),r=new H(t,i),o=new H(s,i);return n.next=o.prev=r,r.next=n.prev=o,o.next=r.prev=n,i.edge=n,i.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),s=this.edge.next.head();return C.set(e.point,t.point,s.point),C.getNormal(this.normal),C.getMidpoint(this.midpoint),this.area=C.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class H{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class Ve{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class N{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class He extends M{constructor(e=[]){super();const t=[],s=[];W===void 0&&console.error("THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull");const n=new W().setFromPoints(e).faces;for(let r=0;r<n.length;r++){const o=n[r];let a=o.edge;do{const h=a.head().point;t.push(h.x,h.y,h.z),s.push(o.normal.x,o.normal.y,o.normal.z),a=a.next}while(a!==o.edge)}this.setAttribute("position",new A(t,3)),this.setAttribute("normal",new A(s,3))}}const G=3,k=3;class Ge{constructor(){d(this,"scene");d(this,"items",[]);const e=new F;this.scene=e.scene;const t=[...new Array(30)].map(()=>[Math.random()*G,Math.random()*k]),i=fe.from(t).voronoi([0,0,G,k]);let n=0;const r=[];for(;;){const o=i.cellPolygon(n);if(o[0][0]==null)break;n++,r.push(o)}r.forEach(o=>{const a=new se,h=o.shift();a.moveTo(h[0],h[1]);let l=0,u=0;o.forEach(b=>{a.lineTo(b[0],b[1]),l+=b[0],u+=b[1]}),l/=o.length,u/=o.length;const p=new ne(a,{steps:1,depth:.1,bevelEnabled:!1}).getAttribute("position").array,m=[];for(let b=0;b<p.length;b+=3)m.push(new w(p[b]-l,p[b+2],p[b+1]-u));const g=new He(m),P=new j({color:new ie(Math.random(),Math.random(),Math.random()),wireframe:!1}),E=new v(g,P);E.position.x+=l,E.position.z+=u,this.scene.add(E);const Y=we(E).shape,T=new U({mass:1});T.addShape(Y),T.angularVelocity.set(3,2,u),T.angularDamping=.8,e.physics.addBody(T),this.items.push({mesh:E,body:T})}),this.apply()}update(){this.items.forEach(e=>{e.mesh.position.set(e.body.position.x,e.body.position.y,e.body.position.z),e.mesh.quaternion.set(e.body.quaternion.x,e.body.quaternion.y,e.body.quaternion.z,e.body.quaternion.w)})}apply(){this.items.forEach(e=>{e.body.position.set(e.mesh.position.x,e.mesh.position.y,e.mesh.position.z),e.body.quaternion.set(e.mesh.quaternion.x,e.mesh.quaternion.y,e.mesh.quaternion.z,e.mesh.quaternion.w)})}renderVoronoi(e){const t=document.createElement("canvas");document.body.appendChild(t),t.style.backgroundColor="#ccc",t.width=G,t.height=k;const s=t.getContext("2d");s.beginPath(),e.render(s),s.lineWidth=.25,s.strokeStyle="#ff0000",s.fillStyle="#ffff33",s.stroke()}}class ke{constructor(){d(this,"scene");d(this,"camera");d(this,"renderer");d(this,"mesh");const e=new F;this.scene=new X,this.camera=e.oCamera,this.renderer=e.renderer;const t=new _(2,2),s=new oe({...Fe});this.mesh=new v(t,s),this.mesh.material.uniforms.resolution.value.x=1/(window.innerWidth*this.renderer.getPixelRatio()),this.mesh.material.uniforms.resolution.value.y=1/(window.innerHeight*this.renderer.getPixelRatio()),this.scene.add(this.mesh)}render(e,t){this.renderer.setRenderTarget(e),this.mesh.material.uniforms.tDiffuse.value=t,this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null)}}class qe{constructor(){d(this,"scene");d(this,"camera");d(this,"renderer");d(this,"target");d(this,"sample");d(this,"boxes",[]);d(this,"floor");d(this,"voronoi");d(this,"fxaa");const e=new F;this.scene=e.scene,this.camera=e.camera,this.renderer=e.renderer,this.target=new re(e.size.width*Math.min(2,window.devicePixelRatio),e.size.height*Math.min(2,window.devicePixelRatio)),this.setUp()}setUp(){const e=new ae(2236962);this.scene.add(e);const t=new le(16777215,.5);t.castShadow=!0;const s=1024;t.shadow.mapSize.width=s,t.shadow.mapSize.height=s,t.position.set(1,3,1),this.scene.add(t);const i=new ce(t);this.scene.add(i),this.voronoi=new Ge,this.floor=new ze,this.fxaa=new ke}update(){this.voronoi.update(),this.renderer.setRenderTarget(this.target),this.renderer.render(this.scene,this.camera),this.fxaa.render(null,this.target.texture)}resize(){}}class Ae{constructor(e,t,s){d(this,"scene");d(this,"world");d(this,"_meshes");d(this,"_material");d(this,"_particleMaterial",new R);d(this,"_sphereGeometry");d(this,"_boxGeometry");d(this,"_planeGeometry");d(this,"_particleGeometry");d(this,"tmpVec0",new S);d(this,"tmpVec1",new S);d(this,"tmpVec2",new S);d(this,"tmpQuat0",new ge);this.scene=e,this.world=t,this._meshes=[],this._material=new j({color:65280,wireframe:!0}),this._particleMaterial=new R({color:16711680,size:10,sizeAttenuation:!1,depthTest:!1}),this._sphereGeometry=new I(1),this._boxGeometry=new L(1,1,1),this._planeGeometry=new _(10,10,10,10),this._particleGeometry=new M,this._particleGeometry.setFromPoints([new w(0,0,0)])}update(){const e=this.world.bodies,t=this._meshes,s=this.tmpVec0,i=this.tmpQuat0;let n=0;for(let r=0;r!==e.length;r++){const o=e[r];for(let a=0;a!==o.shapes.length;a++){const h=o.shapes[a];this._updateMesh(n,o,h);const l=t[n];l&&(o.quaternion.vmult(o.shapeOffsets[a],s),o.position.vadd(s,s),o.quaternion.mult(o.shapeOrientations[a],i),l.position.x=s.x,l.position.y=s.y,l.position.z=s.z,l.quaternion.x=i.x,l.quaternion.y=i.y,l.quaternion.z=i.z,l.quaternion.w=i.w),n++}}for(let r=n;r<t.length;r++){const o=t[r];o&&this.scene.remove(o)}t.length=n}_updateMesh(e,t,s){let i=this._meshes[e];this._typeMatch(i,s)||(i&&this.scene.remove(i),i=this._meshes[e]=this._createMesh(s)),this._scaleMesh(i,s)}_typeMatch(e,t){if(!e)return!1;const s=e.geometry;return s instanceof I&&t instanceof ye||s instanceof L&&t instanceof xe||s instanceof D&&t instanceof ve||s instanceof _&&t instanceof Q||t instanceof be||s.id===t.id&&t instanceof Ee||s.id===t.id&&t instanceof Pe}_createMesh(e){let t,s,i,n,r;const o=this._material;let a=[];switch(e.type){case y.types.SPHERE:t=new v(this._sphereGeometry,o);break;case y.types.BOX:t=new v(this._boxGeometry,o);break;case y.types.CYLINDER:s=new D(e.radiusTop,e.radiusBottom,e.height,e.numSegments),t=new v(s,o);break;case y.types.PLANE:t=new v(this._planeGeometry,o);break;case y.types.PARTICLE:t=new he(this._particleGeometry,this._particleMaterial);break;case y.types.CONVEXPOLYHEDRON:s=new M,e.id=s.id,a=[];for(let l=0;l<e.vertices.length;l+=1){const u=e.vertices[l];a.push(new w(u.x,u.y,u.z))}s.setFromPoints(a);const h=[];for(let l=0;l<e.faces.length;l++){const u=e.faces[l],c=u[0];for(let p=1;p<u.length-1;p++){const m=u[p],g=u[p+1];h.push(c,m,g)}}s.setIndex(h),t=new v(s,o);break;case y.types.TRIMESH:s=new M,e.id=s.id,a=[];for(let l=0;l<e.vertices.length;l+=3)a.push(new w(e.vertices[l],e.vertices[l+1],e.vertices[l+2]));s.setFromPoints(a),t=new v(s,o);break;case y.types.HEIGHTFIELD:s=new M,i=this.tmpVec0,n=this.tmpVec1,r=this.tmpVec2;for(let l=0;l<e.data.length-1;l++)for(let u=0;u<e.data[l].length-1;u++)for(let c=0;c<2;c++)e.getConvexTrianglePillar(l,u,c===0),i.copy(e.pillarConvex.vertices[0]),n.copy(e.pillarConvex.vertices[1]),r.copy(e.pillarConvex.vertices[2]),i.vadd(e.pillarOffset,i),n.vadd(e.pillarOffset,n),r.vadd(e.pillarOffset,r),a.push(new w(i.x,i.y,i.z),new w(n.x,n.y,n.z),new w(r.x,r.y,r.z));s.setFromPoints(a),t=new v(s,o),e.id=s.id;break;default:t=new v;break}return t&&t.geometry&&this.scene.add(t),t}_scaleMesh(e,t){let s,i,n;switch(t.type){case y.types.SPHERE:s=t.radius,e.scale.set(s,s,s);break;case y.types.BOX:i=t.halfExtents,e.scale.copy(new w(i.x,i.y,i.z)),e.scale.multiplyScalar(2);break;case y.types.CONVEXPOLYHEDRON:e.scale.set(1,1,1);break;case y.types.TRIMESH:n=t.scale,e.scale.copy(new w(n.x,n.y,n.z));break;case y.types.HEIGHTFIELD:e.scale.set(1,1,1);break}}}let q;class F{constructor(e){d(this,"scene");d(this,"camera");d(this,"oCamera");d(this,"renderer");d(this,"world");d(this,"physics");d(this,"dd");d(this,"size");d(this,"debug");if(q)return q;!e||(q=this,this.init(e))}init(e){this.debug=new Ce,this.size={width:window.innerWidth,height:window.innerHeight},this.scene=new X,this.camera=new de(45,this.size.width/this.size.height,.1,100),this.camera.position.set(0,6,8),this.camera.lookAt(0,0,0),this.oCamera=new ue(-1,1,1,-1,1,10),this.oCamera.position.set(0,0,10),this.oCamera.lookAt(0,0,0),this.renderer=new pe({canvas:e}),this.renderer.setSize(this.size.width,this.size.height),this.renderer.setPixelRatio(Math.min(2,window.devicePixelRatio)),this.renderer.outputEncoding=me,this.renderer.shadowMap.enabled=!0,this.physics=new Te,this.physics.gravity.set(0,-9.82,0),this.dd=new Ae(this.scene,this.physics),this.world=new qe,new Me(this.camera,e),this.render()}render(){this.debug.begin(),this.physics.step(1/60),this.dd.update(),this.world.update(),this.debug.end(),requestAnimationFrame(()=>this.render())}resize(){}}const Re=document.querySelector(".webgl"),Ie=new F(Re);window.addEventListener("resize",()=>{Ie.resize()});
